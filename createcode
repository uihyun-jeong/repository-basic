ì•„ë‘ì´ë…¸ ì½”ë“œ
#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// I2C ì£¼ì†Œ 0x27, 20ê¸€ì 4ì¤„ ë””ìŠ¤í”Œë ˆì´ ì„¤ì •
LiquidCrystal_I2C lcd(0x27, 20, 4);

// í†µì‹  ì†ë„ (íŒŒì´ì¬ ì½”ë“œì™€ ì¼ì¹˜í•´ì•¼ í•¨)
const long BAUD_RATE = 250000;
const int RELAY_PIN = 3;
const int LED_PIN = LED_BUILTIN;

// í†µì‹  ì—°ê²° ìƒíƒœ í™•ì¸ìš© ë³€ìˆ˜
unsigned long lastCmdTime = 0; Â  Â  Â  // ë§ˆì§€ë§‰ìœ¼ë¡œ ëª…ë ¹ì„ ë°›ì€ ì‹œê°„
const unsigned long TIMEOUT_MS = 3000; // 3ì´ˆê°„ ì‹ í˜¸ ì—†ìœ¼ë©´ ëŠê¹€ìœ¼ë¡œ ê°„ì£¼
bool isConnected = false; Â  Â  Â  Â  Â  Â // í˜„ì¬ íŒŒì´ì¬ê³¼ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì—¬ë¶€

// ============================================================
// ë””ìŠ¤í”Œë ˆì´ ìºì‹œ
// ë¦´ë ˆì´ ë…¸ì´ì¦ˆë¡œ LCDê°€ ì´ˆê¸°í™”ë  ë•Œ, ê¸°ì¡´ í™”ë©´ì„ ë³µêµ¬í•˜ê¸° ìœ„í•œ ì €ì¥ì†Œ
// 4ì¤„ x 21ê¸€ì (20ê¸€ì + ë¬¸ìì—´ ë NULL)
// ============================================================
char displayCache[4][21]; 

// ìºì‹œ ë©”ëª¨ë¦¬ë¥¼ ê³µë°±ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ëŠ” í•¨ìˆ˜
void clearDisplayCache() {
Â  for(int i=0; i<4; i++) {
Â  Â  memset(displayCache[i], ' ', 20); // 20ì¹¸ì„ ê³µë°±ìœ¼ë¡œ ì±„ì›€
Â  Â  displayCache[i][20] = '\0'; Â  Â  Â  // ë¬¸ìì—´ ë í‘œì‹œ
Â  }
}

// -------------------- LCD ì¶œë ¥ ë° ì €ì¥ í•¨ìˆ˜ --------------------
// í™”ë©´ì— ê¸€ìë¥¼ ì¶œë ¥í•˜ë©´ì„œ, ë™ì‹œì— displayCache ë³€ìˆ˜ì—ë„ ë‚´ìš©ì„ ì €ì¥í•¨
void printLcdLineRaw(int row, const char* text) {
Â  char buf[21];
Â  int len = strlen(text);

Â  // ì…ë ¥ëœ í…ìŠ¤íŠ¸ê°€ 20ìë³´ë‹¤ ê¸¸ë©´ ìë¥´ê³ , ì§§ìœ¼ë©´ ë‚˜ë¨¸ì§€ë¥¼ ê³µë°±ìœ¼ë¡œ ì±„ì›€ (ê¸€ì ì°Œêº¼ê¸° ë°©ì§€)
Â  if (len >= 20) {
Â  Â  memcpy(buf, text, 20);
Â  } else {
Â  Â  memcpy(buf, text, len);
Â  Â  memset(buf + len, ' ', 20 - len);
Â  }
Â  buf[20] = '\0';
Â  
Â  // í™”ë©´ì— ì¶œë ¥í•˜ê¸° ì „ì— ë³€ìˆ˜(Cache)ì— ë³µì‚¬í•´ë‘ 
Â  strcpy(displayCache[row], buf);

Â  // ì‹¤ì œ LCDì— ì¶œë ¥
Â  lcd.setCursor(0, row);
Â  lcd.print(buf);
}

// í™”ë©´ ë³µêµ¬ í•¨ìˆ˜
// ë¦´ë ˆì´ ë™ì‘ í›„ LCDë¥¼ ì¬ì´ˆê¸°í™”(init)í•œ ë’¤, ê¸°ì–µí•´ë‘” ë‚´ìš©ì„ ë‹¤ì‹œ ë¿Œë ¤ì¤Œ
void restoreDisplay() {
Â  for(int i=0; i<4; i++) {
Â  Â  lcd.setCursor(0, i);
Â  Â  lcd.print(displayCache[i]);
Â  }
}

// -------------------- ì‹œë¦¬ì–¼ ëª…ë ¹ ì²˜ë¦¬ --------------------
// ìˆ˜ì‹  ë²„í¼ ë° ì¸ë±ìŠ¤
char lcdRxBuf[150];
uint8_t lcdRxIdx = 0;

// "LCD:ì²«ì¤„;ë‘ë²ˆì§¸ì¤„;..." í˜•íƒœì˜ ëª…ë ¹ì„ ë¶„ì„í•´ì„œ í™”ë©´ì— ë„ì›€
void processLcdCommandLine(char* line) {
Â  digitalWrite(LED_PIN, !digitalRead(LED_PIN)); // ë°ì´í„° ìˆ˜ì‹  ì‹œ LED ê¹œë¹¡ì„ (ë™ì‘ í™•ì¸ìš©)
Â  
Â  // í”„ë¡œí† ì½œ í—¤ë” í™•ì¸ ("LCD:" ë¡œ ì‹œì‘í•˜ëŠ”ì§€)
Â  if (strncmp(line, "LCD:", 4) != 0) return;

Â  lastCmdTime = millis(); // í†µì‹  ì‹œê°„ ê°±ì‹  (íƒ€ì„ì•„ì›ƒ ë°©ì§€)
Â  isConnected = true; Â  Â  // ì—°ê²° ìƒíƒœ ON

Â  char* p = line + 4; // "LCD:" ë‹¤ìŒ ê¸€ìë¶€í„° ì‹œì‘
Â  char* lines[4] = { NULL, NULL, NULL, NULL };
Â  int count = 0;

Â  // ì„¸ë¯¸ì½œë¡ (;)ì„ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ìì—´ì„ ì˜ë¼ì„œ 4ê°œ ì¤„ë¡œ ë‚˜ëˆ”
Â  lines[count++] = p;
Â  while (*p && count < 4) {
Â  Â  if (*p == ';') {
Â  Â  Â  *p = '\0'; // ì„¸ë¯¸ì½œë¡ ì„ ë¬¸ìì—´ ì¢…ë£Œ ë¬¸ìë¡œ ë³€ê²½
Â  Â  Â  if (*(p + 1) != '\0') lines[count++] = p + 1; // ë‹¤ìŒ ì¤„ ì‹œì‘ ìœ„ì¹˜ ì €ì¥
Â  Â  }
Â  Â  p++;
Â  }

Â  // ê° ì¤„ì„ LCDì— ì¶œë ¥ (ë‚´ë¶€ì ìœ¼ë¡œ ìºì‹œì—ë„ ì €ì¥ë¨)
Â  for (int row = 0; row < 4; row++) {
Â  Â  if (lines[row]) printLcdLineRaw(row, lines[row]);
Â  Â  else printLcdLineRaw(row, ""); // ë‚´ìš© ì—†ìœ¼ë©´ ë¹ˆ ì¤„ ì¶œë ¥
Â  }
}

// ì‹œë¦¬ì–¼ í¬íŠ¸ ê°ì‹œ ë° ëª…ë ¹ ì‹¤í–‰
void pollSerialCommands() {
Â  while (Serial.available() > 0) {
Â  Â  char c = Serial.read();
Â  Â  
Â  Â  // ì¤„ë°”ê¿ˆ ë¬¸ì(\n)ê°€ ë“¤ì–´ì˜¤ë©´ ëª…ë ¹ ì™„ì„±ìœ¼ë¡œ íŒë‹¨
Â  Â  if (c == '\n') {
Â  Â  Â  if (lcdRxIdx == 0) continue; // ë¹ˆ ì¤„ ë¬´ì‹œ
Â  Â  Â  lcdRxBuf[lcdRxIdx] = '\0'; Â  // ë¬¸ìì—´ ì™„ì„±
Â  Â  Â  lcdRxIdx = 0; Â  Â  Â  Â  Â  Â  Â  Â // ë²„í¼ ì¸ë±ìŠ¤ ì´ˆê¸°í™”

Â  Â  Â  // 1) LCD ë°ì´í„° ìˆ˜ì‹  ëª…ë ¹ ("LCD:...")
Â  Â  Â  if (strncmp(lcdRxBuf, "LCD:", 4) == 0) {
Â  Â  Â  Â  processLcdCommandLine(lcdRxBuf);
Â  Â  Â  }
Â  Â  Â  // 2) ë¦´ë ˆì´ ë„ê¸° ëª…ë ¹ (ì¸¡ì • ì¢…ë£Œ)
Â  Â  Â  else if (strcmp(lcdRxBuf, "RELAY:OFF") == 0) {
Â  Â  Â  Â  digitalWrite(RELAY_PIN, HIGH); // ë¦´ë ˆì´ OFF (High Trigger ë°©ì‹ì¸ ê²½ìš°)
Â  Â  Â  Â  
Â  Â  Â  Â  // â˜…â˜…â˜… [ë…¸ì´ì¦ˆ ëŒ€ì‘ í•µì‹¬ êµ¬ê°„] â˜…â˜…â˜…
Â  Â  Â  Â  // ë¦´ë ˆì´ ì ‘ì ì´ ë–¨ì–´ì§ˆ ë•Œ ìŠ¤íŒŒí¬(ë…¸ì´ì¦ˆ)ë¡œ LCDê°€ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ
Â  Â  Â  Â  delay(200); Â  Â  Â // ë…¸ì´ì¦ˆê°€ ì§€ë‚˜ê°ˆ ë•Œê¹Œì§€ 0.2ì´ˆ ëŒ€ê¸°
Â  Â  Â  Â  lcd.init(); Â  Â  Â // ê¹¨ì§„ LCD í™”ë©´ ê°•ì œ ì¬ì´ˆê¸°í™”
Â  Â  Â  Â  lcd.backlight(); // ë°±ë¼ì´íŠ¸ ë‹¤ì‹œ ì¼œê¸°
Â  Â  Â  Â  
Â  Â  Â  Â  // í™”ë©´ ë³µêµ¬
Â  Â  Â  Â  // ì¬ì´ˆê¸°í™”ë¡œ í™”ë©´ì´ ì§€ì›Œì¡Œìœ¼ë¯€ë¡œ, ìºì‹œì— ì €ì¥ëœ ë§ˆì§€ë§‰ ì¸¡ì •ê°’ì„ ë‹¤ì‹œ ê·¸ë¦¼
Â  Â  Â  Â  restoreDisplay(); 
Â  Â  Â  }
Â  Â  Â  // 3) ë¦´ë ˆì´ ì¼œê¸° ëª…ë ¹ (ì¸¡ì • ì‹œì‘)
Â  Â  Â  else if (strcmp(lcdRxBuf, "RELAY:ON") == 0) {
Â  Â  Â  Â  digitalWrite(RELAY_PIN, LOW); // ë¦´ë ˆì´ ON
Â  Â  Â  Â  
Â  Â  Â  Â  // ì¼¤ ë•Œë„ ë…¸ì´ì¦ˆê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ì¬ì´ˆê¸°í™” ìˆ˜í–‰
Â  Â  Â  Â  delay(200); Â  Â  Â 
Â  Â  Â  Â  lcd.init(); Â  Â  Â 
Â  Â  Â  Â  lcd.backlight();
Â  Â  Â  Â  
Â  Â  Â  Â  // ì¼¤ ë•ŒëŠ” ìƒˆë¡œìš´ ì¸¡ì •ì´ ì‹œì‘ë˜ë¯€ë¡œ ê¸°ì¡´ í™”ë©´(ê²°ê³¼ê°’)ì„ ì§€ì›€
Â  Â  Â  Â  clearDisplayCache();
Â  Â  Â  Â  lcd.clear(); 
Â  Â  Â  }
Â  Â  } 
Â  Â  // ì¤„ë°”ê¿ˆì´ ì•„ë‹ˆë©´ ë²„í¼ì— ê¸€ì ì €ì¥
Â  Â  else if (c != '\r') {
Â  Â  Â  if (lcdRxIdx < sizeof(lcdRxBuf) - 1) lcdRxBuf[lcdRxIdx++] = c;
Â  Â  }
Â  }
}

// íŒŒì´ì¬ í”„ë¡œê·¸ë¨ê³¼ ì—°ê²°ì´ ëŠì–´ì¡ŒëŠ”ì§€ ì²´í¬
void checkConnectionTimeout() {
Â  int relayState = digitalRead(RELAY_PIN); // HIGH=OFF, LOW=ON (íšŒë¡œì— ë”°ë¼ ë‹¤ë¦„)
Â  
Â  // ì—°ê²° ìƒíƒœì˜€ëŠ”ë°, 3ì´ˆ(TIMEOUT_MS) ì´ìƒ ë°ì´í„°ê°€ ì—†ê³ , ë¦´ë ˆì´ê°€ ì¼œì ¸ìˆëŠ”(ì¸¡ì • ì¤‘) ìƒíƒœë¼ë©´
Â  if (isConnected && (millis() - lastCmdTime > TIMEOUT_MS) && (relayState == LOW)) {
Â  Â  isConnected = false;
Â  Â  clearDisplayCache(); // ìºì‹œ ë¹„ì›€
Â  Â  lcd.clear();
Â  Â  
Â  Â  // ëŒ€ê¸° í™”ë©´ ì¶œë ¥
Â  Â  lcd.setCursor(0, 0); lcd.print("Ready to Connect");
Â  Â  lcd.setCursor(0, 1); lcd.print("Waiting...");
Â  }
}

void setup() {
Â  Serial.begin(BAUD_RATE);
Â  
Â  // ì•„ë‘ì´ë…¸ R4 ë“± ìµœì‹  ë³´ë“œì—ì„œ ADC í•´ìƒë„ ì„¤ì • (UNO R3ëŠ” ë¬´ì‹œë¨)
Â  #if defined(ARDUINO_UNOR4_MINIMA) || defined(ARDUINO_UNOR4_WIFI)
Â  Â  analogReadResolution(14);
Â  #endif

Â  pinMode(RELAY_PIN, OUTPUT);
Â  pinMode(LED_PIN, OUTPUT);
Â  digitalWrite(RELAY_PIN, LOW); // ì´ˆê¸° ìƒíƒœ: ë¦´ë ˆì´ ON

Â  lcd.init();
Â  lcd.backlight();
Â  Wire.setClock(400000); // I2C í†µì‹  ì†ë„ ê³ ì† ëª¨ë“œ (400kHz) ì„¤ì •
Â  clearDisplayCache();

Â  // ì´ˆê¸° ëŒ€ê¸° ë©”ì‹œì§€
Â  lcd.setCursor(0, 0); lcd.print("Ready to Connect");
Â  lcd.setCursor(0, 1); lcd.print("Waiting...");
}

void loop() {
Â  // 1. ì‹œë¦¬ì–¼ ëª…ë ¹ ìˆ˜ì‹  ë° ì²˜ë¦¬ (LCD í‘œì‹œ, ë¦´ë ˆì´ ì œì–´)
Â  pollSerialCommands();
Â  
Â  // 2. í†µì‹  ëŠê¹€ ê°ì§€
Â  checkConnectionTimeout();

Â  // 3. ì„¼ì„œ ë°ì´í„° ìƒ˜í”Œë§ ë° ì „ì†¡ (ë¹„ì°¨ë‹¨ ë°©ì‹, 1ms ì£¼ê¸°)
Â  static unsigned long nextSampleMicros = 0;
Â  if ((long)(micros() - nextSampleMicros) >= 0) {
Â  Â  nextSampleMicros = micros() + 1000; // 1000us = 1ms (1kHz ìƒ˜í”Œë§)
Â  Â  
Â  Â  int a0 = analogRead(A0); // ì „ì••/ì „ë¥˜ ì„¼ì„œê°’ ì½ê¸°
Â  Â  int a1 = analogRead(A1);
Â  Â  
Â  Â  // íŒŒì´ì¬ìœ¼ë¡œ ì›ë³¸ ë°ì´í„° ì „ì†¡ (CSV í˜•íƒœ)
Â  Â  Serial.print(a0); Serial.print(','); Serial.println(a1);
Â  }
}


íŒŒì´ì¬ ì½”ë“œ
import serial
from collections import deque
import time
import sys
import threading
import requests
import numpy as np
import pyqtgraph as pg
from PyQt6 import QtWidgets, QtCore, QtGui

# [System] ì¶œë ¥ ë²„í¼ë§ ë°©ì§€ (í„°ë¯¸ë„ ì¶œë ¥ ì¦‰ì‹œ í‘œì‹œ)
sys.stdout.reconfigure(line_buffering=True)

# ==========================================
# 0. ì „ì—­ ì„¤ì • ë° ìƒíƒœ ë³€ìˆ˜
# ==========================================
# [State] ë¬´ë¶€í•˜/ë¶€í•˜ ìƒíƒœ ê°ì§€ ë¡œì§ìš©
is_active_load = False      # í˜„ì¬ ë¶€í•˜ê°€ ì¼œì ¸ìˆëŠ”ì§€ ìƒíƒœ (True/False)
noise_filter_count = 0      # ë¯¸ì„¸ ë¶€í•˜ íŒë³„ì„ ìœ„í•œ ì—°ì† ê°ì§€ ì¹´ìš´í„°

# [Discord] ì•Œë¦¼ ì„¤ì •
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1441817840414883942/k9AMZ0Poxpym93me6qYDngZ_sy81AKlj7ULEEpFnQC3PAzBmoEICiXzS1LMFFP51QrlU"
DISCORD_INTERVAL = 15.0     # ì•Œë¦¼ ì „ì†¡ ì£¼ê¸° (ì´ˆ)
last_discord_time = time.time()

# [Discord] ì´ë¯¸ì§€ ì „ì†¡ ìŠ¤ë ˆë“œ (ë©”ì¸ ë£¨í”„ ì§€ì—° ë°©ì§€)
def send_image_to_discord_thread(image_bytes, v, i, p, q, pf, cost, thd, load_name):
    try:
        now_str = time.strftime('%Y-%m-%d %H:%M:%S')
        cost_mW = cost
        
        load_header = f" ğŸ”Œ  í˜„ì¬ ë¶€í•˜: `{load_name}`\n" if load_name else ""
        
        message_content = (
            load_header +
            f" âš¡  **Power Monitor Report**\n"
            f" ğŸ“…  Time: `{now_str}`\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"**Voltage (V)** : `{v:.1f} V`\n"
            f"**Current (I)** : `{i:.2f} A`\n"
            f"**Active Power (P)** : `{p:.1f} W`\n"
            f"**Reactive Power (Q)** : `{q:.1f} Var`\n"
            f"**Power Factor (PF)** : `{pf:.4f}`\n"
            f"**Accumulated Cost** : `{cost_mW:.1f} mWon`\n"
            f"**THD (Current)** : `{thd*100:.1f} %`\n"
            f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        files = {"file": ("graph_snapshot.png", image_bytes, "image/png")}
        data = {"content": message_content}
        
        response = requests.post(DISCORD_WEBHOOK_URL, data=data, files=files)
        if response.status_code not in [200, 204]:
            print(f">> [Discord] ì „ì†¡ ì‹¤íŒ¨: {response.status_code}")
    except Exception as e:
        print(f">> [Discord] ì—ëŸ¬: {e}")

# ==========================================
# 1. ì‹œë¦¬ì–¼ í†µì‹  ì„¤ì • (Arduino Connection)
# ==========================================
PORT = 'COM5'
BAUD = 250000

try:
    ser = serial.Serial(port=PORT, baudrate=BAUD, timeout=0.1)
    
    # [Safety] ì•„ë‘ì´ë…¸ ë¦¬ì…‹ ëŒ€ê¸° (ì—°ê²° ì§í›„ ë°ì´í„° ì˜¤ì—¼ ë°©ì§€)
    print("Connecting... (Waiting 2s for Arduino Reset)")
    time.sleep(2.0)
    
    # ë²„í¼ ë¹„ìš°ê¸° (ì“°ë ˆê¸° ë°ì´í„° ì œê±°)
    ser.reset_input_buffer()
    ser.reset_output_buffer()
    print("Connected to", ser.port)
except Exception as e:
    print(f"ì‹œë¦¬ì–¼ ì—°ê²° ì‹¤íŒ¨: {e}")
    sys.exit()

# ==========================================
# 2. ê³„ì¸¡ ë° ì—°ì‚° íŒŒë¼ë¯¸í„°
# ==========================================
# [Calibration] ìœ„ìƒ ë° ADC ë³´ì • ê³„ìˆ˜
PHASE_CORR = 0.314          # ìœ„ìƒ ë³´ì •ê°’ (Rad) - ì´ˆê¸°ê°’, ì´í›„ ìë™ ë³´ì •ë¨
Changing = 5.0 / 16383.0    # ADC(14bit) -> Voltage ë³€í™˜ ê³„ìˆ˜
Voffset = 2.4800            # ì „ì•• ì„¼ì„œ ì˜¤í”„ì…‹ (2.5V ì¤‘ì‹¬)
Vsec_gain = 7.81            # ì „ì•• ì„¼ì„œ 2ì°¨ì¸¡ ê²Œì¸
TURNS_RATIO = 16.9          # ë³€ì••ê¸° ê¶Œì„ ë¹„
SEN_ZERO_V = 2.5            # ì „ë¥˜ ì„¼ì„œ 0ì  ì „ì••
SEN_SENS = 0.1              # ì „ë¥˜ ì„¼ì„œ ê°ë„ (mV/A ë“±)

# [Signal Processing] FFT ë° ìƒ˜í”Œë§
SAMPLE_RATE = 1000.0        # ìƒ˜í”Œë§ ì£¼íŒŒìˆ˜ (Hz)
FFT_POINTS = 1024           # FFT ë¶„ì„ í¬ì¸íŠ¸ ìˆ˜
FFT_INTERVAL = 0.5          # FFT ì—…ë°ì´íŠ¸ ì£¼ê¸° (ì´ˆ)
next_fft_time = 0.0

# [Gain] ìµœì¢… ë³´ì • ê³„ìˆ˜
V_GAIN_CAL  = 1.015         # ì „ì•• ìµœì¢… íŠœë‹
I_GAIN_CAL  = 1.03          # ì „ë¥˜ ìµœì¢… íŠœë‹

# [Cost] ìš”ê¸ˆ ê³„ì‚° ë³€ìˆ˜
COST_PER_KWH = 12000.0      # kWhë‹¹ ìš”ê¸ˆ (ë‹¨ìœ„: ì›)
energy_Wh = 0.0
cost = 0.0
last_energy_time = time.time()

# [Protection] ë³´í˜¸ ê¸°ëŠ¥ ì„ê³„ê°’
loadCode = 'X'              # ë¶€í•˜ íƒ€ì… (R/L/C/X)
I_MIN = 0.065               # ìµœì†Œ ì „ë¥˜ ê°ì§€ ë ˆë²¨
POWER_LIMIT_W = 500.0       # ê³¼ë¶€í•˜ ì°¨ë‹¨ ê¸°ì¤€ (W)
I_LIMIT_A     = 10          # ê³¼ì „ë¥˜ ì°¨ë‹¨ ê¸°ì¤€ (A)
current_load_name = ""
calibrating = False         # ë³´ì • ë™ì‘ ì¤‘ í”Œë˜ê·¸

# ==========================================
# 3. ì‚¬ìš©ì ì…ë ¥ ë° ì´ˆê¸°í™”
# ==========================================
try:
    USER_MINUTES = float(input("ì‚¬ìš© ì‹œê°„ ì œí•œ(ë¶„, 0=ë¬´ì œí•œ): "))
except:
    USER_MINUTES = 0.0
try:
    USER_LIMIT_COST = float(input("ì‚¬ìš© ê¸ˆì•¡ í•œë„(ì›, 0=ë¬´ì œí•œ): "))
except:
    USER_LIMIT_COST = 0.0

start_time = time.time()
relay_tripped = False

# ==========================================
# 4. ì œì–´ ë° ìœ í‹¸ í•¨ìˆ˜
# ==========================================
def relay_off():
    """ ë¦´ë ˆì´ ì°¨ë‹¨ ëª…ë ¹ ì „ì†¡ (ë…¸ì´ì¦ˆ ë°©ì§€ ë”œë ˆì´ í¬í•¨) """
    global relay_tripped
    if relay_tripped: return
    relay_tripped = True
    print(">>> RELAY OFF")
    try:
        ser.write(b"RELAY:OFF\n")
        # [Noise Defense] ë¦´ë ˆì´ ìŠ¤ìœ„ì¹­ ë…¸ì´ì¦ˆê°€ í†µì‹ ì„ ë°©í•´í•˜ì§€ ì•Šë„ë¡ ëŒ€ê¸°
        time.sleep(0.5)
    except: pass

def reset_and_turn_on():
    """ ì‹œìŠ¤í…œ ë¦¬ì…‹ ë° ë¦´ë ˆì´ ë³µêµ¬ """
    global relay_tripped, start_time, energy_Wh, cost, last_history_time
    relay_tripped = False
    start_time = time.time()
    energy_Wh = 0.0
    cost = 0.0
    p_history.clear(); q_history.clear(); cost_history.clear()
    last_history_time = time.time()
    try:
        ser.write(b"RELAY:ON\n")
        time.sleep(0.5)
    except: pass

def on_load_name_changed(text):
    global current_load_name
    current_load_name = text.strip()

def adc_to_voltage_primary(adc):
    return ((adc*Changing - Voffset) * Vsec_gain * TURNS_RATIO) * V_GAIN_CAL

def adc_to_current(adc):
    return ((adc*Changing - SEN_ZERO_V) / SEN_SENS) * I_GAIN_CAL

def make_lcd_line(text):
    return f"{text:<20}"[:20]

def send_lcd(lines):
    """ ì•„ë‘ì´ë…¸ LCDë¡œ ë©”ì‹œì§€ ì „ì†¡ (4ì¤„) """
    packet = "LCD:" + ";".join(lines) + "\n"
    # print(f">> Sending to Arduino: {packet.strip()}") # ë””ë²„ê·¸ìš©
    try: ser.write(packet.encode())
    except: pass

# ==========================================
# 5. ë°ì´í„° ë²„í¼ ë° GUI ì´ˆê¸°í™”
# ==========================================
MAX_POINTS = 500
VIEW_POINTS = 100
v_buf = deque([0.0] * MAX_POINTS, maxlen=MAX_POINTS)
i_buf = deque([0.0] * MAX_POINTS, maxlen=MAX_POINTS)

MAX_HISTORY = 200
p_history = deque([], maxlen=MAX_HISTORY)
q_history = deque([], maxlen=MAX_HISTORY)
cost_history = deque([], maxlen=MAX_HISTORY)
last_history_time = time.time()
last_lcd_time = time.time()

# [GUI Setup] PyQtGraph ì„¤ì •
pg.setConfigOption('background', 'w')
pg.setConfigOption('foreground', 'k')
pg.setConfigOption('antialias', True)

app = QtWidgets.QApplication([])
main_win = QtWidgets.QWidget()
main_win.setWindowTitle("Power Monitor (Hybrid Mode)")
main_layout = QtWidgets.QVBoxLayout(main_win)

# [UI] ì»¨íŠ¸ë¡¤ íŒ¨ë„
control_layout = QtWidgets.QHBoxLayout()
btn_calib = QtWidgets.QPushButton("No-load Calibrate (0A)")
btn_calib.setFixedHeight(40)
control_layout.addWidget(btn_calib)

btn_pf_calib = QtWidgets.QPushButton("PF Calibrate (R load)")
btn_pf_calib.setFixedHeight(40)
control_layout.addWidget(btn_pf_calib)
main_layout.addLayout(control_layout)

# [UI] ë¶€í•˜ ì´ë¦„ ì…ë ¥
load_layout = QtWidgets.QHBoxLayout()
load_layout.addWidget(QtWidgets.QLabel("í˜„ì¬ ë¶€í•˜ ì´ë¦„:"))
edit_load = QtWidgets.QLineEdit()
edit_load.setPlaceholderText("ì˜ˆ: ë“œë¼ì´ê¸°, ë…¸íŠ¸ë¶")
load_layout.addWidget(edit_load)
main_layout.addLayout(load_layout)

# [UI] ë¦¬ì…‹ ë²„íŠ¼
btn_reset = QtWidgets.QPushButton("Relay Reset / ON")
btn_reset.setFixedHeight(40)
main_layout.addWidget(btn_reset)

# [UI] ê·¸ë˜í”„ ì˜ì—­
gwin = pg.GraphicsLayoutWidget()
main_layout.addWidget(gwin)
main_win.resize(1100, 950)
main_win.show()

# ê·¸ë˜í”„ 1: ì „ì•• íŒŒí˜•
plot_v = gwin.addPlot(row=0, col=0, title="Voltage Waveform (Raw)")
plot_v.showGrid(x=True, y=True)
plot_v.setXRange(0, VIEW_POINTS)
plot_v.setYRange(-300, 300)
curve_v = plot_v.plot(pen=pg.mkPen('r', width=3))

# ê·¸ë˜í”„ 2: ì „ë¥˜ íŒŒí˜•
plot_i = gwin.addPlot(row=1, col=0, title="Current Waveform (Raw)")
plot_i.showGrid(x=True, y=True)
plot_i.setXRange(0, VIEW_POINTS)
plot_i.setYRange(-10, 10)
curve_i = plot_i.plot(pen=pg.mkPen('b', width=3))

# ê·¸ë˜í”„ 3: ê³ ì¡°íŒŒ(Harmonics) ì‹œê°„ ë„ë©”ì¸
plot_harm = gwin.addPlot(row=2, col=0, title="Harmonics (Time Domain)")
plot_harm.addLegend()
plot_harm.setXRange(0, VIEW_POINTS)
curve_h1 = plot_harm.plot(pen='orange', name='1st')
curve_h3 = plot_harm.plot(pen='m', name='3rd')
curve_h5 = plot_harm.plot(pen='g', name='5th')

# ê·¸ë˜í”„ 4: P/Q íŠ¸ë Œë“œ
plot_pq = gwin.addPlot(row=3, col=0, title="P / Q Trend")
plot_pq.addLegend()
curve_p = plot_pq.plot(pen=pg.mkPen('r', width=3), name='P')
curve_q = plot_pq.plot(pen=pg.mkPen('b', width=3, style=QtCore.Qt.PenStyle.DashLine), name='Q')

# ê·¸ë˜í”„ 5: ìš”ê¸ˆ
plot_cost = gwin.addPlot(row=4, col=0, title="Cost")
curve_cost = plot_cost.plot(pen='k')

# [UI] í˜ì´ì € ë‹¤ì´ì–´ê·¸ë¨ ìœˆë„ìš°
win_phasor = pg.GraphicsLayoutWidget(title="Phasor Diagram")
win_phasor.resize(500, 500)
win_phasor.show()
plot_phasor = win_phasor.addPlot()
plot_phasor.setAspectLocked(True)
plot_phasor.setXRange(-1.2, 1.2)
plot_phasor.setYRange(-1.2, 1.2)
plot_phasor.showGrid(x=True, y=True)
theta = np.linspace(0, 2 * np.pi, 100)
plot_phasor.plot(np.cos(theta), np.sin(theta), pen=pg.mkPen('k', style=QtCore.Qt.PenStyle.DotLine))
vec_v = plot_phasor.plot(pen=pg.mkPen('b', width=3)) # ì „ì•• ë²¡í„°
vec_i = plot_phasor.plot(pen=pg.mkPen('r', width=3)) # ì „ë¥˜ ë²¡í„°
win_phasor.nextRow()
label_phasor_info = win_phasor.addLabel("Waiting...", size="14pt")

# [UI] FFT ìŠ¤í™íŠ¸ëŸ¼ ìœˆë„ìš°
win_fft = pg.GraphicsLayoutWidget(title="Current Harmonic Spectrum (dB)")
win_fft.resize(600, 400)
win_fft.show()
plot_fft = win_fft.addPlot()
plot_fft.setXRange(0, 420)
plot_fft.setYRange(-100, 0)
plot_fft.showGrid(x=True, y=True)
plot_fft.getAxis('bottom').setTicks([[(60 * k, f"{k}H") for k in range(1, 8)]])
curve_fft = plot_fft.plot(pen='k', fillLevel=-120, brush=(100,100,100,50))

# ==========================================
# 6. ë³´ì •(Calibration) ë¡œì§
# ==========================================
def no_load_calibrate():
    """ ë¬´ë¶€í•˜ ìƒíƒœì—ì„œ 0ì (Zero Offset) ìë™ ë³´ì • """
    global Voffset, SEN_ZERO_V, calibrating
    if calibrating: return
    calibrating = True
    print(">>> ë¬´ë¶€í•˜ ë³´ì • ì‹œì‘")
    btn_calib.setEnabled(False); btn_calib.setText("Calibrating...")
    QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.CursorShape.WaitCursor)
    
    success = False
    try:
        try:
            while ser.in_waiting: ser.readline() # ë²„í¼ ë¹„ìš°ê¸°
        except: pass
        
        v_samples, i_samples = [], []
        t0 = time.time()
        while time.time() - t0 < 5.0: # 5ì´ˆê°„ ë°ì´í„° ìˆ˜ì§‘
            if ser.in_waiting:
                try:
                    line = ser.readline().decode(errors="ignore").strip()
                    parts = line.split(',')
                    if len(parts)==2:
                        v_samples.append(int(parts[0]))
                        i_samples.append(int(parts[1]))
                except: pass
            time.sleep(0.002)
            
        if len(v_samples) > 100:
            mean_v = sum(v_samples)/len(v_samples)
            mean_i = sum(i_samples)/len(i_samples)
            Voffset = mean_v * Changing
            SEN_ZERO_V = mean_i * Changing
            print(f"New Voffset={Voffset:.4f}, ZERO_V={SEN_ZERO_V:.4f}")
            success = True
    finally:
        calibrating = False
        btn_calib.setEnabled(True); btn_calib.setText("No-load Calibrate")
        QtWidgets.QApplication.restoreOverrideCursor()
        if success:
            QtWidgets.QMessageBox.information(main_win, "Done", "ë¬´ë¶€í•˜ 0ì  ë³´ì • ì™„ë£Œ")

def compute_fundamental_power(v_arr, i_arr, Fs=SAMPLE_RATE):
    """
    [í•µì‹¬ ì•Œê³ ë¦¬ì¦˜] FFTë¥¼ ì´ìš©í•œ ê¸°ë³¸íŒŒ(60Hz) ì „ë ¥ ë° ìœ„ìƒì°¨ ê³„ì‚°
    Return: P1, Q1, S1, PF1, Vrms1, Irms1, phi(ìœ„ìƒì°¨)
    """
    N = len(v_arr)
    if N < 200: return None
    
    # 1. ìœˆë„ìš° í•¨ìˆ˜ ì ìš© (DC ì œê±° ë° Spectral Leakage ë°©ì§€)
    n = np.arange(N)
    window = np.hamming(N)
    v_win = (v_arr - np.mean(v_arr)) * window
    i_win = (i_arr - np.mean(i_arr)) * window
    
    # 2. DFTë¡œ 60Hz ì„±ë¶„ ì¶”ì¶œ
    w = np.exp(-1j * 2 * np.pi * 60 * n / Fs)
    V1 = np.sum(v_win * w)
    I1 = np.sum(i_win * w)
    
    # 3. RMS ë° ì „ë ¥ ê³„ì‚°
    wr = np.sqrt(np.mean(window ** 2))
    K = np.sqrt(2) / (N * wr + 1e-12)
    Vrms1 = K * abs(V1)
    Irms1 = K * abs(I1)
    
    if Vrms1 < 1e-6 or Irms1 < 1e-6: return None
    S1 = Vrms1 * Irms1
    
    # 4. ìœ„ìƒì°¨(phi) ê³„ì‚°: ì „ì••ê°ë„ - ì „ë¥˜ê°ë„
    phi = np.angle(V1) - np.angle(I1)
    
    PF1 = np.cos(phi)
    P1  = S1 * PF1
    Q1  = S1 * np.sin(phi)
    
    return P1, Q1, S1, PF1, Vrms1, Irms1, phi

def calibrate_PF_resistive(v_arr, i_raw):
    """ ì €í•­ ë¶€í•˜(ì—­ë¥  1.0)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìœ„ìƒ ë³´ì •ê°’(PHASE_CORR) ìë™ íŠœë‹ """
    global PHASE_CORR
    # í˜„ì¬ ì„¤ì •ê°’ìœ¼ë¡œ ì„ì‹œ ë³´ì •
    shift = (PHASE_CORR / (2*np.pi)) * (SAMPLE_RATE/60.0)
    idx = np.arange(len(i_raw))
    i_shifted = np.interp(idx + shift, idx, i_raw)
    
    res = compute_fundamental_power(v_arr, i_shifted)
    if res is None: return
    P1, Q1, _, _, _, _, _ = res
    
    if abs(P1) < 10:
        print("ë¶€í•˜ ë¶€ì¡±"); return
        
    # ì˜¤ì°¨ ê°ë„ ê³„ì‚°í•˜ì—¬ ë³´ì •ê°’ ì—…ë°ì´íŠ¸ (ì§€ìƒ/ì§„ìƒ ë°©í–¥ ê³ ë ¤)
    phi_err = np.arctan2(Q1, P1)
    PHASE_CORR -= phi_err
    print(f"New Phase Corr: {np.degrees(PHASE_CORR):.2f}Â°")

def pf_calibrate_button_clicked():
    global calibrating
    if calibrating: return
    
    v_arr = np.array(v_buf)
    i_arr = np.array(i_buf)
    if len(v_arr) < 200:
        QtWidgets.QMessageBox.warning(main_win,"Err","ë°ì´í„° ë¶€ì¡±")
        return
        
    calibrating = True
    btn_pf_calib.setEnabled(False)
    QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.CursorShape.WaitCursor)
    try:
        Nwin = min(FFT_POINTS, len(v_arr))
        calibrate_PF_resistive(v_arr[-Nwin:], i_arr[-Nwin:])
        QtWidgets.QMessageBox.information(main_win, "Done", f"ë³´ì • ì™„ë£Œ\në³´ì •ê°: {np.degrees(PHASE_CORR):.2f}Â°")
    except Exception as e:
        print(e)
    finally:
        calibrating = False
        btn_pf_calib.setEnabled(True)
        QtWidgets.QApplication.restoreOverrideCursor()

# ==========================================
# 7. ë©”ì¸ ì—…ë°ì´íŠ¸ ë£¨í”„ (íƒ€ì´ë¨¸)
# ==========================================
Vrms, Irms, P, Q, S, PF, THD_I = 0,0,0,0,0,0,0
P_disp, Q_disp = 0, 0

def update():
    global Vrms, Irms, P, Q, S, PF, THD_I, P_disp, Q_disp
    global energy_Wh, cost, last_energy_time, last_history_time, last_lcd_time
    global loadCode, next_fft_time, last_discord_time
    global is_active_load, noise_filter_count

    if calibrating: return

    # 1. ì‹œë¦¬ì–¼ ë°ì´í„° ìˆ˜ì‹  (Raw Data -> Buffer)
    while ser.in_waiting:
        try:
            line = ser.readline().decode().strip()
            parts = line.split(',')
            if len(parts)==2:
                v_buf.append(adc_to_voltage_primary(int(parts[0])))
                i_buf.append(adc_to_current(int(parts[1])))
        except: pass
    if len(v_buf) > MAX_POINTS+100: pass 
    
    v_arr = np.array(v_buf)
    i_raw = np.array(i_buf)
    if len(v_arr) < 20: return

    # [Step 1] ì‹œê°„ì¶• ë³´ì • (Phase Correction)
    # ì„¼ì„œ ì§€ì—° ë“±ì„ ë³´ì •í•˜ê¸° ìœ„í•´ ì „ë¥˜ íŒŒí˜•ì„ ë¯¸ì„¸í•˜ê²Œ ì´ë™ (ë³´ì •ê°’ ì ìš©)
    shift_amt = (PHASE_CORR / (2 * np.pi)) * (SAMPLE_RATE / 60.0)
    idxs = np.arange(len(i_raw))
    i_arr = np.interp(idxs + shift_amt, idxs, i_raw)

    # ê·¸ë˜í”„ ì—…ë°ì´íŠ¸ (Raw Waveform)
    curve_v.setData(v_arr)
    curve_i.setData(i_arr)

    # [Step 2] ì „ë ¥ ì§€í‘œ ê³„ì‚°
    Nwin = min(FFT_POINTS, len(v_arr))
    v_seg = v_arr[-Nwin:]
    i_seg = i_arr[-Nwin:]
    
    Vrms = float(np.sqrt(np.mean(v_seg**2)))
    Vrms = max(0.0, Vrms - 2.0) # ë…¸ì´ì¦ˆ í”Œë¡œì–´ ì œê±°
    Irms = float(np.sqrt(np.mean((i_seg - np.mean(i_seg))**2)))
    S = Vrms * Irms

    # [Step 3] ê¸°ë³¸íŒŒ ë¶„ì„ (ìœ„ìƒì°¨, P, Q ì¶”ì¶œ)
    fund = compute_fundamental_power(v_seg, i_seg)
    if fund is not None and S > 1e-6:
        _, _, _, _, _, _, phi_val = fund
        raw_phi_rad = phi_val
        PF = np.cos(raw_phi_rad)
        P  = S * PF
        Q  = S * np.sin(raw_phi_rad)
    else:
        PF, P, Q, raw_phi_rad = 0.0, 0.0, 0.0, 0.0

    # ---------------------------------------------------------
    # [Step 4] ë…¸ì´ì¦ˆ í•„í„° ë° íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ (Hysteresis Filter)
    # ---------------------------------------------------------
    # ëª©ì : 0~4W ìˆ˜ì¤€ì˜ ë…¸ì´ì¦ˆì™€ ì‹¤ì œ ì†Œí˜• ë¶€í•˜(5W~)ë¥¼ êµ¬ë¶„
    UPPER_THRESHOLD = 6.0   # ì¼œì§ íŒì • ê¸°ì¤€ (W)
    LOWER_THRESHOLD = 2.0   # êº¼ì§ íŒì • ê¸°ì¤€ (W)
    REQUIRED_COUNT = 10     # ì—°ì† ê°ì§€ íšŸìˆ˜ (ì•½ 1ì´ˆ)
    abs_P = abs(P)

    if is_active_load:
        # [ìƒíƒœ: ì¼œì§] êº¼ì§ˆ ë•ŒëŠ” ë°˜ì‘ì„±ì„ ìœ„í•´ ê¸°ì¤€ ì´í•˜ ì¦‰ì‹œ ì°¨ë‹¨
        if abs_P < LOWER_THRESHOLD:
            is_active_load = False
            noise_filter_count = 0
            # 0ì²˜ë¦¬
            P, Q, S, PF = 0.0, 0.0, 0.0, 0.0
            if Irms < 0.5: Irms = 0.0
    else:
        # [ìƒíƒœ: êº¼ì§] ì¼œì§ˆ ë•ŒëŠ” ë…¸ì´ì¦ˆ ë°©ì§€ë¥¼ ìœ„í•´ ì—°ì† ê°ì§€ í•„ìš”
        if abs_P > UPPER_THRESHOLD:
            noise_filter_count += 1
            if noise_filter_count >= REQUIRED_COUNT:
                is_active_load = True # ë¶€í•˜ ì¸ì •
                noise_filter_count = 0
            else:
                # ì•„ì§ ì¹´ìš´íŠ¸ ë¶€ì¡± -> ë…¸ì´ì¦ˆë¡œ ê°„ì£¼í•˜ê³  0 ì²˜ë¦¬
                P, Q, S, PF = 0.0, 0.0, 0.0, 0.0
                if Irms < 0.5: Irms = 0.0
        else:
            # ê¸°ì¤€ ë¯¸ë‹¬ ì‹œ ì¹´ìš´í„° ë¦¬ì…‹
            noise_filter_count = 0
            P, Q, S, PF = 0.0, 0.0, 0.0, 0.0
            if Irms < 0.5: Irms = 0.0

    # [Step 5] ë¶€í•˜ íƒ€ì… íŒë³„
    if P == 0.0: loadCode = 'x'
    elif abs(PF) > 0.95: loadCode = 'R' # ì €í•­ì„±
    elif Q > 0: loadCode = 'L'          # ìœ ë„ì„± (ëª¨í„° ë“±)
    elif Q < 0: loadCode = 'C'          # ìš©ëŸ‰ì„±
    else: loadCode = 'x'

    # [Display] ê°’ ì•ˆì •í™” (EMA í•„í„°)
    alpha = 1.0
    P_disp = (1-alpha)*P_disp + alpha*P
    Q_disp = (1-alpha)*Q_disp + alpha*Q

    # [Display] í˜ì´ì € ë‹¤ì´ì–´ê·¸ë¨ ì—…ë°ì´íŠ¸
    vec_v.setData([0, 1], [0, 0])
    if Irms >= I_MIN and S >= 5.0:
        draw_ang = -raw_phi_rad
        vec_i.setData([0, np.cos(draw_ang)], [0, np.sin(draw_ang)])
        deg = np.degrees(abs(raw_phi_rad))
        status = f"{deg:.1f}Â° ({'Resistive' if loadCode=='R' else 'Lag' if Q>0 else 'Lead'})"
    else:
        vec_i.setData([0,0], [0,0])
        status = "No Load"
    label_phasor_info.setText(f"<b style='color:blue'>V:{Vrms:.1f}V</b> | <b style='color:red'>I:{Irms:.2f}A</b><br>Phase: {status}")

    # [Analysis] THD ë° ê³ ì¡°íŒŒ ë¶„ì„
    if Irms < I_MIN:
        THD_I = 0.0
        curve_fft.setData([], []); curve_h1.setData([], []); curve_h3.setData([], []); curve_h5.setData([], [])
    else:
        now = time.time()
        if now >= next_fft_time:
            next_fft_time = now + FFT_INTERVAL
            i_fft = i_arr[-FFT_POINTS:]
            # FFT ì—°ì‚°
            win = np.hamming(len(i_fft))
            i_win = (i_fft - np.mean(i_fft)) * win
            fft = np.fft.rfft(i_win)
            mags = np.abs(fft)
            freqs = np.fft.rfftfreq(len(i_fft), 1/SAMPLE_RATE)
            
            # ìŠ¤í™íŠ¸ëŸ¼ í‘œì‹œ
            mx = mags.max()
            db = 20*np.log10((mags+1e-12)/mx) if mx>0 else np.full_like(mags, -120)
            curve_fft.setData(freqs[freqs<=420], db[freqs<=420])
            
            # THD ê³„ì‚°
            bin_w = SAMPLE_RATE/len(i_fft)
            k1 = int(round(60.0/bin_w))
            fund_mag = mags[k1]
            harm_sq_sum = 0.0
            for h in range(2, 8):
                c_idx = k1 * h
                for off in range(-2, 3):
                    idx = c_idx + off
                    if 0 <= idx < len(mags) and mags[idx] > fund_mag * 0.005:
                        harm_sq_sum += mags[idx]**2
            THD_I = np.sqrt(harm_sq_sum)/fund_mag if fund_mag>0 else 0.0
            
            # ê³ ì¡°íŒŒ íŒŒí˜• ì¶”ì¶œ (ì‹œê°í™”ìš©)
            scale = 2.0 / np.sum(win)
            t = np.arange(VIEW_POINTS)
            def get_wave(order, color_curve):
                idx = k1 * order
                if idx < len(mags):
                    amp = mags[idx] * scale
                    color_curve.setData(amp * np.sin(2*np.pi*60*order*t/SAMPLE_RATE))
                else: color_curve.setData([], [])
            get_wave(1, curve_h1); get_wave(3, curve_h3); get_wave(5, curve_h5)

    # ---------------------------------------------------------
    # [Step 6] ìš”ê¸ˆ ì ì‚° ë° ë³´í˜¸(Protection) ë¡œì§
    # ---------------------------------------------------------
    now = time.time()
    dt = now - last_energy_time
    last_energy_time = now
    
    # ì—ë„ˆì§€ ì ì‚°
    energy_Wh += P * dt / 3600.0
    cost = energy_Wh * COST_PER_KWH / 1000.0
    
    # íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
    if now - last_history_time >= 1.0:
        last_history_time = now
        p_history.append(P_disp); q_history.append(Q_disp); cost_history.append(cost)
        curve_p.setData(p_history); curve_q.setData(q_history); curve_cost.setData(cost_history)

    # ë³´í˜¸ ê¸°ëŠ¥ ì²´í¬ (Priority: Current > Power > Cost > Time)
    elapsed = (now - start_time) / 60.0
    trip = False
    stop_cause = None

    if I_LIMIT_A > 0.0 and Irms >= I_LIMIT_A:
        trip = True; stop_cause = "OC"          # Over Current
    elif POWER_LIMIT_W > 0.0 and P >= POWER_LIMIT_W:
        trip = True; stop_cause = "POWER"       # Over Power
    elif USER_LIMIT_COST > 0.0 and cost >= USER_LIMIT_COST:
        trip = True; stop_cause = "COST"        # Cost Limit
    elif USER_MINUTES > 0 and elapsed >= USER_MINUTES:
        trip = True; stop_cause = "TIME"        # Time Over

    if trip and not relay_tripped:
        # ì•„ë‘ì´ë…¸ë¡œ ì°¨ë‹¨ ë©”ì‹œì§€ ì „ì†¡ (ì˜ë¬¸ í•„ìˆ˜)
        if stop_cause == "TIME":
            send_lcd([make_lcd_line("Timer Finished"), make_lcd_line(f"Used: {elapsed:5.1f} min"), make_lcd_line("RELAY OFF"), make_lcd_line("Reset Required")])
        elif stop_cause == "OC":
            send_lcd([make_lcd_line("Over Current!"), make_lcd_line(f"Peak I = {Irms:5.2f} A"), make_lcd_line("RELAY OFF"), make_lcd_line("Check Load")])
        elif stop_cause == "POWER":
            send_lcd([make_lcd_line("Over Power!"), make_lcd_line(f"Peak P = {P:6.1f} W"), make_lcd_line("RELAY OFF"), make_lcd_line("Check Load")])
        elif stop_cause == "COST":
            send_lcd([make_lcd_line("Cost Limit!"), make_lcd_line(f"Cost= {cost:6.1f} mW"), make_lcd_line("RELAY OFF"), make_lcd_line("Insert Coin")])
        
        time.sleep(0.5) # ë©”ì‹œì§€ ì „ì†¡ ë³´ì¥ ëŒ€ê¸°
        relay_off()

    # LCD ì—…ë°ì´íŠ¸ (ì •ìƒ ë™ì‘ ì¤‘ì¼ ë•Œë§Œ)
    if not relay_tripped and now - last_lcd_time >= 1.0:
        last_lcd_time = now
        lines = [
            make_lcd_line(f"V={Vrms:5.1f}V I={Irms:5.2f}A"),
            make_lcd_line(f"P={P_disp:6.1f}W Q={Q_disp:6.1f}"),
            make_lcd_line(f"PF={PF:6.4f} C={cost:6.2f}mW"),
            make_lcd_line(f"THD={THD_I*100:5.1f}% Type={loadCode}")
        ]
        send_lcd(lines)

    # ë””ìŠ¤ì½”ë“œ ë³´ê³ ì„œ ì „ì†¡
    if now - last_discord_time >= DISCORD_INTERVAL:
        last_discord_time = now
        pix = main_win.grab()
        ba = QtCore.QByteArray()
        buf = QtCore.QBuffer(ba)
        buf.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
        pix.save(buf, "PNG")
        threading.Thread(
            target=send_image_to_discord_thread,
            args=(ba.data(), Vrms, Irms, P_disp, Q_disp, PF, cost, THD_I, current_load_name),
            daemon=True
        ).start()

# ì‹œê·¸ë„ ì—°ê²°
btn_reset.clicked.connect(reset_and_turn_on)
edit_load.textChanged.connect(on_load_name_changed)
btn_calib.clicked.connect(no_load_calibrate)
btn_pf_calib.clicked.connect(pf_calibrate_button_clicked)

# ==========================================
# 8. í”„ë¡œê·¸ë¨ ì‹¤í–‰ ë° ì¢…ë£Œ ì²˜ë¦¬
# ==========================================
timer = QtCore.QTimer()
timer.timeout.connect(update)
timer.start(100) # 100ms ê°„ê²© ì—…ë°ì´íŠ¸

def cleanup():
    print("\n>>> Exiting...")
    if timer.isActive(): timer.stop()
    if 'ser' in globals() and ser.is_open:
        try:
            # ì¢…ë£Œ í™”ë©´ ì „ì†¡
            lines = ["Ready to Connect    ", "Waiting...          ", "PC Program Closed   ", "                    "]
            packet = "LCD:" + ";".join(lines) + "\n"
            ser.write(packet.encode())
            time.sleep(0.5)
        except Exception as e:
            print(f"Exit msg error: {e}")
        try: ser.close()
        except: pass
    print("Serial closed.")

app.aboutToQuit.connect(cleanup)
try:
    sys.exit(app.exec())
except KeyboardInterrupt:
    cleanup()
    sys.exit()
